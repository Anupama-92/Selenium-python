A software design pattern is a general, reusable solution to a commonly occuring problem within a given context in software design
Design Pattern are three types
1. Creational(Polymorphism) - Create Objects systematically.
2. Structural(Inheritance) - Establish relationships between software components.Accomplish functional and non functional goals.
3. Behavioral(Methods) - Objects interaction

Pattern  Context
1. Participants - Classes involved to form a design pattern, Roles
2. Quality Attributes - Non functional requirements, reliability and performance. It effects on the entire software architectural solutions
3. Forces
4. Consequences - Worse performance

Pattern language
1. Name
2. Context
3. Problem
4. Solution
5. Related patterns

Types of patterns
1. Factory Pattern - Factory encapsulates object creation.
When we use
Uncertainties in types of objects
Decision to be made at run time regarding what classes to use
2. Abstract Factory - Builds on Factory parent
When we use - When the user expects to receive a family of related objects but don't know which family it is untill run time
Abstract Factory - pet factory
Concrete Factory - dog and cat category
Concrete Product -
    DOg and dog food
    Cat and cat food

Page Object Model (POM) - Use POM when the UI frequently changes, as it keeps the code clean and readable.
Factory Design Pattern - Use Factory when the project needs to support multiple browsers or page types that are instantiated dynamically based on input conditions.
Singleton - Use Singleton when you want to limit the WebDriver instance to one per test suite or test run.
Strategy -  Use Strategy when you have different actions or workflows that can vary and you want the flexibility to switch between them.
Decorator - Use Decorator when you want to enhance or modify the behavior of existing methods dynamically, like adding logging, screenshot capturing, or retry mechanisms.
Command - Use Command if you want to encapsulate user actions and execute them in a more structured or deferred way, particularly for complex workflows.
Observer - Use Observer when you need multiple components to react to test events such as test failures, retries, or specific actions.


How to Choose the Right Design Pattern:
1. Project Size and Complexity:

Small projects: Start with Page Object Model (POM).
Large projects: Consider combining POM with Factory, Singleton, or Strategy patterns to enhance flexibility and maintainability.
Test Suite Goals:

2. Maintainability: Use POM to organize test logic.
Scalability: Combine Factory, Strategy, or Command for extensibility.
Performance: Use Singleton for managing WebDriver instances efficiently.
3.Reusability:

Use Decorator or Command patterns to add or reuse test actions without modifying existing methods.
4. Customization:

Observer or Strategy is helpful if you need dynamic behavior or multiple reactions to test events (e.g., logging, reporting).

